#version 460

struct BVHNode 
{
    vec4 minBounds; // xyz = min, w = leftChild (child index or -1 to flag as leaf)
    vec4 maxBounds; // xyz = max, w = rightChild (child index or triangle index if leaf)
    // triangle index is pointing to the first index of a triangle, or startTriangleIndex * 3
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba32f) uniform image2D outputImage; // Storage image

layout(binding = 1, set = 0) readonly buffer VertexBuffer          // Vertex SSBO
{
    float vertices[];
};
layout(binding = 2, set = 0) readonly buffer IndexBuffer           // Index SSBO
{
    uint indices[];
};
layout(binding = 3, set = 0) readonly buffer BVHBuffer             // BVH SSBO
{
    BVHNode nodes[]; 
};

// Helper function to get a vertex by index
vec3 getVertex(uint vertexIndex) 
{
    uint offset = vertexIndex * 3;  // 3 floats per vertex
    return vec3(vertices[offset], vertices[offset + 1], vertices[offset + 2]);
}

void main()
{
    // The resolution of the buffer, which in this case is a hardcoded vector
    // of 2 unsigned integers:
    const ivec2 resolution = imageSize(outputImage);

    // Get the coordinates of the pixel for this invocation:
    //
    // .-------.-> x
    // |       |
    // |       |
    // '-------'
    // v
    // y
    const uvec2 pixel = gl_GlobalInvocationID.xy;

    // If the pixel is outside of the image, don't do anything:
    if((pixel.x >= resolution.x) || (pixel.y >= resolution.y))
    {
        return;
    }

    // Create a vector of 3 floats with a different color per pixel.
    const vec4 pixelColor = vec4(float(pixel.x) / resolution.x,  // Red
                                float(pixel.y) / resolution.y,  // Green
                                0.0,                            // Blue
                                1.0);                           // Alpha

    imageStore(outputImage, ivec2(pixel), pixelColor);
}