#version 460

struct BVHNode {
    vec4 minBounds;
    vec4 maxBounds;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba32f) uniform image2D outputImage;
layout(binding = 1, set = 0) readonly buffer VertexBuffer {
    float vertices[];
};
layout(binding = 2, set = 0) readonly buffer IndexBuffer {
    uint indices[];
};
layout(binding = 3, set = 0) readonly buffer BVHBuffer {
    BVHNode nodes[];
};

const vec3 cameraPos = vec3(0.0, 0.0, 5.0);
const vec3 cameraDir = vec3(0.0, 0.0, -1.0);
const vec3 cameraUp = vec3(0.0, 1.0, 0.0);
const float fov = 60.0;

vec3 getVertex(uint vertexIndex) {
    uint offset = vertexIndex * 3;
    return vec3(vertices[offset], vertices[offset + 1], vertices[offset + 2]);
}

struct Ray {
    vec3 origin;
    vec3 dir;
};

bool intersectAABB(Ray ray, vec3 minBounds, vec3 maxBounds, out float tMin, out float tMax) {
    vec3 invDir = 1.0 / ray.dir;
    vec3 t0 = (minBounds - ray.origin) * invDir;
    vec3 t1 = (maxBounds - ray.origin) * invDir;
    vec3 tNear = min(t0, t1);
    vec3 tFar = max(t0, t1);
    tMin = max(max(tNear.x, tNear.y), tNear.z);
    tMax = min(min(tFar.x, tFar.y), tFar.z);
    return tMin <= tMax && tMax >= 0.0;
}

bool intersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t) {
    const float EPSILON = 0.000001;
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 h = cross(ray.dir, edge2);
    float a = dot(edge1, h);
    if (abs(a) < EPSILON) return false;
    float f = 1.0 / a;
    vec3 s = ray.origin - v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) return false;
    vec3 q = cross(s, edge1);
    float v = f * dot(ray.dir, q);
    if (v < 0.0 || u + v > 1.0) return false;
    t = f * dot(edge2, q);
    return t > EPSILON;
}

float traceRay(Ray ray) {
    float closestT = 1e30;
    int stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        int nodeIdx = stack[--stackPtr];
        BVHNode node = nodes[nodeIdx];
        float tMin, tMax;
        if (intersectAABB(ray, node.minBounds.xyz, node.maxBounds.xyz, tMin, tMax)) {
            int leftChild = int(node.minBounds.w);
            int rightChild = int(node.maxBounds.w);
            if (leftChild == -1) {
                uint triIdx = uint(rightChild) * 3;
                vec3 v0 = getVertex(indices[triIdx]);
                vec3 v1 = getVertex(indices[triIdx + 1]);
                vec3 v2 = getVertex(indices[triIdx + 2]);
                float t;
                if (intersectTriangle(ray, v0, v1, v2, t) && t < closestT) {
                    closestT = t;
                }
            } else {
                stack[stackPtr++] = leftChild;
                stack[stackPtr++] = rightChild;
            }
        }
    }
    return closestT;
}

void main()
{
    const ivec2 resolution = imageSize(outputImage);
    const uvec2 pixel = gl_GlobalInvocationID.xy;

    if (pixel.x >= uint(resolution.x) || pixel.y >= uint(resolution.y)) {
        return;
    }

    float ndcX = (2.0 * float(pixel.x) / float(resolution.x)) - 1.0;
    float ndcY = (2.0 * float(pixel.y) / float(resolution.y)) - 1.0;
    float aspect = float(resolution.x) / float(resolution.y);
    float tanFov = tan(radians(fov * 0.5));
    vec3 right = normalize(cross(cameraDir, cameraUp));
    vec3 up = normalize(cross(right, cameraDir));
    vec3 rayDir = normalize(cameraDir + (ndcX * tanFov * aspect) * right - (ndcY * tanFov) * up);
    Ray ray = Ray(cameraPos, rayDir);

    float depth = traceRay(ray);
    float normalizedDepth = (depth < 1e30) ? (depth / 10.0) : 1.0;
    normalizedDepth = clamp(normalizedDepth, 0.0, 1.0);
    vec4 pixelColor = vec4(vec3(normalizedDepth), 1.0);
    imageStore(outputImage, ivec2(pixel), pixelColor);
}