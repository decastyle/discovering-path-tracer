#version 460

struct BVHNode 
{
    vec4 minBounds;
    vec4 maxBounds;
};

struct Ray 
{
    vec3 origin;
    vec3 dir;
};

struct HitInfo 
{
    float t;        // Distance to hit
    vec3 position;  // Hit position
    vec3 normal;    // Surface normal
    uint triIdx;    // Triangle index (for material lookup later)
    bool hit;       // True if a hit occurred
};

struct PushConstants
{
    uint sample_batch;
};

layout(push_constant) uniform PushConsts
{
    PushConstants pushConstants;
};

struct LightInfo
{
    vec3 lightPos;
    float lightIntensity;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba32f) uniform image2D outputImage;

layout(binding = 1, set = 0) readonly buffer VertexBuffer 
{
    float vertices[];
};

layout(binding = 2, set = 0) readonly buffer IndexBuffer 
{
    uint indices[];
};

layout(binding = 3, set = 0) readonly buffer BVHBuffer 
{
    BVHNode nodes[];
};

layout(std140, binding = 4) uniform CameraBuffer 
{
    vec3 cameraPos;
    vec3 cameraDir;
    vec3 cameraUp;
    vec3 fov;
} camera;

vec3 getVertex(uint vertexIndex) 
{
    uint offset = vertexIndex * 3;
    return vec3(vertices[offset], vertices[offset + 1], vertices[offset + 2]);
}

bool intersectAABB(Ray ray, vec3 minBounds, vec3 maxBounds, out float tMin, out float tMax) 
{
    vec3 invDir = 1.0 / ray.dir;
    vec3 t0 = (minBounds - ray.origin) * invDir;
    vec3 t1 = (maxBounds - ray.origin) * invDir;
    vec3 tNear = min(t0, t1);
    vec3 tFar = max(t0, t1);
    tMin = max(max(tNear.x, tNear.y), tNear.z);
    tMax = min(min(tFar.x, tFar.y), tFar.z);
    return tMin <= tMax && tMax >= 0.0;
}

bool intersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t) 
{
    const float EPSILON = 0.000001;
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 h = cross(ray.dir, edge2);
    float a = dot(edge1, h);
    if (abs(a) < EPSILON) return false;
    float f = 1.0 / a;
    vec3 s = ray.origin - v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) return false;
    vec3 q = cross(s, edge1);
    float v = f * dot(ray.dir, q);
    if (v < 0.0 || u + v > 1.0) return false;
    t = f * dot(edge2, q);
    return t > EPSILON;
}

HitInfo traceRay(Ray ray) 
{
    HitInfo hitInfo = HitInfo(1e30, vec3(0.0), vec3(0.0), 0, false);
    float closestT = 1e30;
    int stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) 
    {
        int nodeIdx = stack[--stackPtr];
        BVHNode node = nodes[nodeIdx];
        float tMin, tMax;
        if (intersectAABB(ray, node.minBounds.xyz, node.maxBounds.xyz, tMin, tMax)) 
        {
            int leftChild = int(node.minBounds.w);
            int rightChild = int(node.maxBounds.w);

            if (leftChild == -1) 
            {
                uint triIdx = uint(rightChild) * 3;
                vec3 v0 = getVertex(indices[triIdx]);
                vec3 v1 = getVertex(indices[triIdx + 1]);
                vec3 v2 = getVertex(indices[triIdx + 2]);
                float t;
                if (intersectTriangle(ray, v0, v1, v2, t) && t < hitInfo.t) 
                {
                    hitInfo.t = t;
                    hitInfo.position = ray.origin + ray.dir * t;
                    hitInfo.normal = normalize(cross(v1 - v0, v2 - v0)); // Simple normal
                    hitInfo.triIdx = uint(rightChild);
                    hitInfo.hit = true;
                }
            } 
            else 
            {
                stack[stackPtr++] = leftChild;
                stack[stackPtr++] = rightChild;
            }
        }
    }
    return hitInfo;
}

// Simple random number generator (for diffuse sampling)
uint rngState;
float stepAndOutputRNGFloat(inout uint rngState) 
{
    rngState = rngState * 747796405u + 2891336453u;
    uint result = ((rngState >> ((rngState >> 28u) + 4u)) ^ rngState) * 277803737u;
    result = (result >> 22u) ^ result;
    return float(result) / 4294967295.0;
}

vec2 randomGaussian(inout uint rngState) 
{
    const float u1 = max(1e-38, stepAndOutputRNGFloat(rngState));
    const float u2 = stepAndOutputRNGFloat(rngState);
    const float r = sqrt(-2.0 * log(u1));
    const float theta = 2.0 * 3.141592653589793238462643383279502884197169399375105820974944 * u2;
    return r * vec2(cos(theta), sin(theta));
}

// Sample cosine-weighted hemisphere
vec3 sampleHemisphere(vec3 normal, inout uint rngState) 
{
    float r1 = stepAndOutputRNGFloat(rngState);
    float r2 = stepAndOutputRNGFloat(rngState);
    float theta = acos(sqrt(1.0 - r1));
    float phi = 2.0 * 3.14159 * r2;
    vec3 localDir = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));

    // Align with normal
    vec3 up = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, normal));
    vec3 bitangent = cross(normal, tangent);
    return tangent * localDir.x + bitangent * localDir.y + normal * localDir.z;
}

vec3 pathTrace(Ray ray, uint seed, LightInfo lightInfo) 
{
    vec3 throughput = vec3(1.0); // Accumulated light contribution
    vec3 radiance = vec3(0.0);   // Total radiance
    const int MAX_DEPTH = 4;     // Limit bounces

    rngState = seed;

    for (int depth = 0; depth < MAX_DEPTH; ++depth) 
    {
        HitInfo hit = traceRay(ray);
        if (!hit.hit) 
        {
            radiance += throughput * vec3(0.8); // Background color
            break;
        }

        // Direct lighting (diffuse)
        vec3 lightDir = normalize(lightInfo.lightPos - hit.position);
        float diffuse = max(dot(hit.normal, lightDir), 0.0);
        vec3 albedo = vec3(0.8); // Fixed diffuse albedo
        vec3 directLight = vec3(0.0);

        // Shadow ray to light
        Ray shadowRay = Ray(hit.position + hit.normal * 0.001, lightDir); // Offset to avoid self-intersection
        HitInfo shadowHit = traceRay(shadowRay);

        float lightDist = length(lightInfo.lightPos - hit.position);
        if (!shadowHit.hit || shadowHit.t >= lightDist - 0.001) // No occlusion or hit beyond light
        { 
            directLight = albedo * diffuse * lightInfo.lightIntensity;
        }
        radiance += throughput * directLight;

        // Indirect lighting (diffuse)
        vec3 bounceDir = sampleHemisphere(hit.normal, rngState);
        throughput *= albedo * dot(hit.normal, bounceDir); // Cosine term included
        ray = Ray(hit.position + hit.normal * 0.001, bounceDir); // Offset to avoid self-intersection
    }

    return radiance;
}

void main()
{   
    const ivec2 resolution = imageSize(outputImage);
    const uvec2 pixel = gl_GlobalInvocationID.xy;

    if (pixel.x >= uint(resolution.x) || pixel.y >= uint(resolution.y)) 
    {
        return;
    }

    float ndcX = (2.0 * float(pixel.x) / float(resolution.x)) - 1.0;
    float ndcY = (2.0 * float(pixel.y) / float(resolution.y)) - 1.0;
    float aspect = float(resolution.x) / float(resolution.y);

    // Seed RNG with pixel coords and sample batch
    uint seed = uint((pushConstants.sample_batch * resolution.y + pixel.y) * resolution.x + pixel.x);
    rngState = seed;

    // Add jitter to NDC coordinates (anti-aliasing)
    vec2 jitter = randomGaussian(rngState);
    float jitterScale = 0.5; // Scale to keep jitter within half a pixel
    ndcX += jitter.x * jitterScale / float(resolution.x);
    ndcY += jitter.y * jitterScale / float(resolution.y);

    float tanFov = tan(radians(camera.fov.x * 0.5));
    vec3 right = normalize(cross(camera.cameraDir, -camera.cameraUp));
    vec3 up = normalize(cross(right, camera.cameraDir));
    vec3 rayDir = normalize(camera.cameraDir + (ndcX * tanFov * aspect) * -right - (ndcY * tanFov) * up);

    Ray ray = Ray(camera.cameraPos, rayDir);                    // Ray to trace
    LightInfo lightInfo = LightInfo(vec3(-3.0, 5.0, 0.0), 1.0); // Light info

    vec3 color = pathTrace(ray, seed, lightInfo);

    vec4 prevColor = imageLoad(outputImage, ivec2(pixel));
    vec4 newColor = (prevColor * float(pushConstants.sample_batch) + vec4(color, 1.0)) / float(pushConstants.sample_batch + 1);
    imageStore(outputImage, ivec2(pixel), newColor);
}