#version 460

struct BVHNode 
{
    vec4 minBounds;
    vec4 maxBounds;
};

struct Ray 
{
    vec3 origin;
    vec3 dir;
};

struct HitInfo {
    float t;        // Distance to hit
    vec3 position;  // Hit position
    vec3 normal;    // Surface normal
    uint triIdx;    // Triangle index (for material lookup later)
    bool hit;       // True if a hit occurred
};

struct LightInfo
{
    vec3 lightPos;
    float lightIntensity;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba32f) uniform image2D outputImage;

layout(binding = 1, set = 0) readonly buffer VertexBuffer 
{
    float vertices[];
};

layout(binding = 2, set = 0) readonly buffer IndexBuffer 
{
    uint indices[];
};

layout(binding = 3, set = 0) readonly buffer BVHBuffer 
{
    BVHNode nodes[];
};

layout(std140, binding = 4) uniform CameraBuffer 
{
    vec3 cameraPos;
    vec3 cameraDir;
    vec3 cameraUp;
    vec3 fov;
} camera;

vec3 getVertex(uint vertexIndex) 
{
    uint offset = vertexIndex * 3;
    return vec3(vertices[offset], vertices[offset + 1], vertices[offset + 2]);
}

bool intersectAABB(Ray ray, vec3 minBounds, vec3 maxBounds, out float tMin, out float tMax) 
{
    vec3 invDir = 1.0 / ray.dir;
    vec3 t0 = (minBounds - ray.origin) * invDir;
    vec3 t1 = (maxBounds - ray.origin) * invDir;
    vec3 tNear = min(t0, t1);
    vec3 tFar = max(t0, t1);
    tMin = max(max(tNear.x, tNear.y), tNear.z);
    tMax = min(min(tFar.x, tFar.y), tFar.z);
    return tMin <= tMax && tMax >= 0.0;
}

bool intersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t) 
{
    const float EPSILON = 0.000001;
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 h = cross(ray.dir, edge2);
    float a = dot(edge1, h);
    if (abs(a) < EPSILON) return false;
    float f = 1.0 / a;
    vec3 s = ray.origin - v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) return false;
    vec3 q = cross(s, edge1);
    float v = f * dot(ray.dir, q);
    if (v < 0.0 || u + v > 1.0) return false;
    t = f * dot(edge2, q);
    return t > EPSILON;
}

HitInfo traceRay(Ray ray) 
{
    HitInfo hitInfo = HitInfo(1e30, vec3(0.0), vec3(0.0), 0, false);
    float closestT = 1e30;
    int stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) 
    {
        int nodeIdx = stack[--stackPtr];
        BVHNode node = nodes[nodeIdx];
        float tMin, tMax;
        if (intersectAABB(ray, node.minBounds.xyz, node.maxBounds.xyz, tMin, tMax)) 
        {
            int leftChild = int(node.minBounds.w);
            int rightChild = int(node.maxBounds.w);

            if (leftChild == -1) 
            {
                uint triIdx = uint(rightChild) * 3;
                vec3 v0 = getVertex(indices[triIdx]);
                vec3 v1 = getVertex(indices[triIdx + 1]);
                vec3 v2 = getVertex(indices[triIdx + 2]);
                float t;
                if (intersectTriangle(ray, v0, v1, v2, t) && t < hitInfo.t) 
                {
                    hitInfo.t = t;
                    hitInfo.position = ray.origin + ray.dir * t;
                    hitInfo.normal = normalize(cross(v1 - v0, v2 - v0)); // Simple normal
                    hitInfo.triIdx = uint(rightChild);
                    hitInfo.hit = true;
                }
            } 
            else 
            {
                stack[stackPtr++] = leftChild;
                stack[stackPtr++] = rightChild;
            }
        }
    }
    return hitInfo;
}

vec3 computeDiffuseShading(HitInfo hitInfo, LightInfo lightInfo) {
    if (!hitInfo.hit) return vec3(0.3); // Background color

    vec3 lightDir = normalize(lightInfo.lightPos - hitInfo.position);
    float diffuse = max(dot(hitInfo.normal, lightDir), 0.0);
    vec3 albedo = vec3(0.8); // Simple diffuse albedo (gray)
    vec3 diffuseColor = albedo * diffuse * lightInfo.lightIntensity + 0.1;

    return diffuseColor;
}

void main()
{   
    const ivec2 resolution = imageSize(outputImage);
    const uvec2 pixel = gl_GlobalInvocationID.xy;

    if (pixel.x >= uint(resolution.x) || pixel.y >= uint(resolution.y)) 
    {
        return;
    }

    float ndcX = (2.0 * float(pixel.x) / float(resolution.x)) - 1.0;
    float ndcY = (2.0 * float(pixel.y) / float(resolution.y)) - 1.0;
    float aspect = float(resolution.x) / float(resolution.y);

    float tanFov = tan(radians(camera.fov.x * 0.5));
    vec3 right = normalize(cross(camera.cameraDir, -camera.cameraUp));
    vec3 up = normalize(cross(right, camera.cameraDir));
    vec3 rayDir = normalize(camera.cameraDir + (ndcX * tanFov * aspect) * -right - (ndcY * tanFov) * up);

    Ray ray = Ray(camera.cameraPos, rayDir);    // Ray to trace

    HitInfo hitInfo = traceRay(ray);                // Hit info for shading

    LightInfo lightInfo = LightInfo(vec3(-3.0, 5.0, 0.0), 1.0); // Light info
    vec3 color = computeDiffuseShading(hitInfo, lightInfo);         // Compute shading

    vec4 pixelColor = vec4(vec3(color), 1.0);
    imageStore(outputImage, ivec2(pixel), pixelColor);
}